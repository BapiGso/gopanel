//go:build linux || darwin || freebsd

package headscale

func init() {
	if _, err := os.Stat(confPath); os.IsNotExist(err) {
		err := os.MkdirAll(filepath.Dir(confPath), 0755)
		if err != nil {
			log.Fatalf("无法创建目录: %v", err)
		}
		content :=
			"---\n# headscale will look for a configuration file named `config.yaml` (or `config.json`) in the following order:\n#\n# - `/etc/headscale`\n# - `~/.headscale`\n# - current working directory\n\n# The url clients will connect to.\n# Typically this will be a domain like:\n#\n# https://myheadscale.example.com:443\n#\nserver_url: http://127.0.0.1:8080\n\n# Address to listen to / bind to on the server\n#\n# For production:\n# listen_addr: 0.0.0.0:8080\nlisten_addr: 127.0.0.1:8080\n\n# Address to listen to /metrics, you may want\n# to keep this endpoint private to your internal\n# network\n#\nmetrics_listen_addr: 127.0.0.1:9090\n\n# Address to listen for gRPC.\n# gRPC is used for controlling a headscale server\n# remotely with the CLI\n# Note: Remote access _only_ works if you have\n# valid certificates.\n#\n# For production:\n# grpc_listen_addr: 0.0.0.0:50443\ngrpc_listen_addr: 127.0.0.1:50443\n\n# Allow the gRPC admin interface to run in INSECURE\n# mode. This is not recommended as the traffic will\n# be unencrypted. Only enable if you know what you\n# are doing.\ngrpc_allow_insecure: false\n\n# The Noise section includes specific configuration for the\n# TS2021 Noise protocol\nnoise:\n  # The Noise private key is used to encrypt the\n  # traffic between headscale and Tailscale clients when\n  # using the new Noise-based protocol.\n  private_key_path: /var/lib/headscale/noise_private.key\n\n# List of IP prefixes to allocate tailaddresses from.\n# Each prefix consists of either an IPv4 or IPv6 address,\n# and the associated prefix length, delimited by a slash.\n# It must be within IP ranges supported by the Tailscale\n# client - i.e., subnets of 100.64.0.0/10 and fd7a:115c:a1e0::/48.\n# See below:\n# IPv6: https://github.com/tailscale/tailscale/blob/22ebb25e833264f58d7c3f534a8b166894a89536/net/tsaddr/tsaddr.go#LL81C52-L81C71\n# IPv4: https://github.com/tailscale/tailscale/blob/22ebb25e833264f58d7c3f534a8b166894a89536/net/tsaddr/tsaddr.go#L33\n# Any other range is NOT supported, and it will cause unexpected issues.\nprefixes:\n  v6: fd7a:115c:a1e0::/48\n  v4: 100.64.0.0/10\n\n  # Strategy used for allocation of IPs to nodes, available options:\n  # - sequential (default): assigns the next free IP from the previous given IP.\n  # - random: assigns the next free IP from a pseudo-random IP generator (crypto/rand).\n  allocation: sequential\n\n# DERP is a relay system that Tailscale uses when a direct\n# connection cannot be established.\n# https://tailscale.com/blog/how-tailscale-works/#encrypted-tcp-relays-derp\n#\n# headscale needs a list of DERP servers that can be presented\n# to the clients.\nderp:\n  server:\n    # If enabled, runs the embedded DERP server and merges it into the rest of the DERP config\n    # The Headscale server_url defined above MUST be using https, DERP requires TLS to be in place\n    enabled: false\n\n    # Region ID to use for the embedded DERP server.\n    # The local DERP prevails if the region ID collides with other region ID coming from\n    # the regular DERP config.\n    region_id: 999\n\n    # Region code and name are displayed in the Tailscale UI to identify a DERP region\n    region_code: \"headscale\"\n    region_name: \"Headscale Embedded DERP\"\n\n    # Listens over UDP at the configured address for STUN connections - to help with NAT traversal.\n    # When the embedded DERP server is enabled stun_listen_addr MUST be defined.\n    #\n    # For more details on how this works, check this great article: https://tailscale.com/blog/how-tailscale-works/\n    stun_listen_addr: \"0.0.0.0:3478\"\n\n    # Private key used to encrypt the traffic between headscale DERP\n    # and Tailscale clients.\n    # The private key file will be autogenerated if it's missing.\n    #\n    private_key_path: /var/lib/headscale/derp_server_private.key\n\n    # This flag can be used, so the DERP map entry for the embedded DERP server is not written automatically,\n    # it enables the creation of your very own DERP map entry using a locally available file with the parameter DERP.paths\n    # If you enable the DERP server and set this to false, it is required to add the DERP server to the DERP map using DERP.paths\n    automatically_add_embedded_derp_region: true\n\n    # For better connection stability (especially when using an Exit-Node and DNS is not working),\n    # it is possible to optionally add the public IPv4 and IPv6 address to the Derp-Map using:\n    ipv4: 1.2.3.4\n    ipv6: 2001:db8::1\n\n  # List of externally available DERP maps encoded in JSON\n  urls:\n    - https://controlplane.tailscale.com/derpmap/default\n\n  # Locally available DERP map files encoded in YAML\n  #\n  # This option is mostly interesting for people hosting\n  # their own DERP servers:\n  # https://tailscale.com/kb/1118/custom-derp-servers/\n  #\n  # paths:\n  #   - /etc/headscale/derp-example.yaml\n  paths: []\n\n  # If enabled, a worker will be set up to periodically\n  # refresh the given sources and update the derpmap\n  # will be set up.\n  auto_update_enabled: true\n\n  # How often should we check for DERP updates?\n  update_frequency: 24h\n\n# Disables the automatic check for headscale updates on startup\ndisable_check_updates: false\n\n# Time before an inactive ephemeral node is deleted?\nephemeral_node_inactivity_timeout: 30m\n\ndatabase:\n  # Database type. Available options: sqlite, postgres\n  # Please note that using Postgres is highly discouraged as it is only supported for legacy reasons.\n  # All new development, testing and optimisations are done with SQLite in mind.\n  type: sqlite\n\n  # Enable debug mode. This setting requires the log.level to be set to \"debug\" or \"trace\".\n  debug: false\n\n  # GORM configuration settings.\n  gorm:\n    # Enable prepared statements.\n    prepare_stmt: true\n\n    # Enable parameterized queries.\n    parameterized_queries: true\n\n    # Skip logging \"record not found\" errors.\n    skip_err_record_not_found: true\n\n    # Threshold for slow queries in milliseconds.\n    slow_threshold: 1000\n\n  # SQLite config\n  sqlite:\n    path: /var/lib/headscale/db.sqlite\n\n    # Enable WAL mode for SQLite. This is recommended for production environments.\n    # https://www.sqlite.org/wal.html\n    write_ahead_log: true\n\n  # # Postgres config\n  # Please note that using Postgres is highly discouraged as it is only supported for legacy reasons.\n  # See database.type for more information.\n  # postgres:\n  #   # If using a Unix socket to connect to Postgres, set the socket path in the 'host' field and leave 'port' blank.\n  #   host: localhost\n  #   port: 5432\n  #   name: headscale\n  #   user: foo\n  #   pass: bar\n  #   max_open_conns: 10\n  #   max_idle_conns: 10\n  #   conn_max_idle_time_secs: 3600\n\n  #   # If other 'sslmode' is required instead of 'require(true)' and 'disabled(false)', set the 'sslmode' you need\n  #   # in the 'ssl' field. Refers to https://www.postgresql.org/docs/current/libpq-ssl.html Table 34.1.\n  #   ssl: false\n\n### TLS configuration\n#\n## Let's encrypt / ACME\n#\n# headscale supports automatically requesting and setting up\n# TLS for a domain with Let's Encrypt.\n#\n# URL to ACME directory\nacme_url: https://acme-v02.api.letsencrypt.org/directory\n\n# Email to register with ACME provider\nacme_email: \"\"\n\n# Domain name to request a TLS certificate for:\ntls_letsencrypt_hostname: \"\"\n\n# Path to store certificates and metadata needed by\n# letsencrypt\n# For production:\ntls_letsencrypt_cache_dir: /var/lib/headscale/cache\n\n# Type of ACME challenge to use, currently supported types:\n# HTTP-01 or TLS-ALPN-01\n# See: docs/ref/tls.md for more information\ntls_letsencrypt_challenge_type: HTTP-01\n# When HTTP-01 challenge is chosen, letsencrypt must set up a\n# verification endpoint, and it will be listening on:\n# :http = port 80\ntls_letsencrypt_listen: \":http\"\n\n## Use already defined certificates:\ntls_cert_path: \"\"\ntls_key_path: \"\"\n\nlog:\n  # Output formatting for logs: text or json\n  format: text\n  level: info\n\n## Policy\n# headscale supports Tailscale's ACL policies.\n# Please have a look to their KB to better\n# understand the concepts: https://tailscale.com/kb/1018/acls/\npolicy:\n  # The mode can be \"file\" or \"database\" that defines\n  # where the ACL policies are stored and read from.\n  mode: file\n  # If the mode is set to \"file\", the path to a\n  # HuJSON file containing ACL policies.\n  path: \"\"\n\n## DNS\n#\n# headscale supports Tailscale's DNS configuration and MagicDNS.\n# Please have a look to their KB to better understand the concepts:\n#\n# - https://tailscale.com/kb/1054/dns/\n# - https://tailscale.com/kb/1081/magicdns/\n# - https://tailscale.com/blog/2021-09-private-dns-with-magicdns/\n#\n# Please note that for the DNS configuration to have any effect,\n# clients must have the `--accept-dns=true` option enabled. This is the\n# default for the Tailscale client. This option is enabled by default\n# in the Tailscale client.\n#\n# Setting _any_ of the configuration and `--accept-dns=true` on the\n# clients will integrate with the DNS manager on the client or\n# overwrite /etc/resolv.conf.\n# https://tailscale.com/kb/1235/resolv-conf\n#\n# If you want stop Headscale from managing the DNS configuration\n# all the fields under `dns` should be set to empty values.\ndns:\n  # Whether to use [MagicDNS](https://tailscale.com/kb/1081/magicdns/).\n  magic_dns: true\n\n  # Defines the base domain to create the hostnames for MagicDNS.\n  # This domain _must_ be different from the server_url domain.\n  # `base_domain` must be a FQDN, without the trailing dot.\n  # The FQDN of the hosts will be\n  # `hostname.base_domain` (e.g., _myhost.example.com_).\n  base_domain: example.com\n\n  # List of DNS servers to expose to clients.\n  nameservers:\n    global:\n      - 1.1.1.1\n      - 1.0.0.1\n      - 2606:4700:4700::1111\n      - 2606:4700:4700::1001\n\n      # NextDNS (see https://tailscale.com/kb/1218/nextdns/).\n      # \"abc123\" is example NextDNS ID, replace with yours.\n      # - https://dns.nextdns.io/abc123\n\n    # Split DNS (see https://tailscale.com/kb/1054/dns/),\n    # a map of domains and which DNS server to use for each.\n    split:\n      {}\n      # foo.bar.com:\n      #   - 1.1.1.1\n      # darp.headscale.net:\n      #   - 1.1.1.1\n      #   - 8.8.8.8\n\n  # Set custom DNS search domains. With MagicDNS enabled,\n  # your tailnet base_domain is always the first search domain.\n  search_domains: []\n\n  # Extra DNS records\n  # so far only A-records are supported (on the tailscale side)\n  # See: docs/ref/dns.md\n  extra_records: []\n  #   - name: \"grafana.myvpn.example.com\"\n  #     type: \"A\"\n  #     value: \"100.64.0.3\"\n  #\n  #   # you can also put it in one line\n  #   - { name: \"prometheus.myvpn.example.com\", type: \"A\", value: \"100.64.0.3\" }\n\n  # DEPRECATED\n  # Use the username as part of the DNS name for nodes, with this option enabled:\n  # node1.username.example.com\n  # while when this is disabled:\n  # node1.example.com\n  # This is a legacy option as Headscale has have this wrongly implemented\n  # while in upstream Tailscale, the username is not included.\n  use_username_in_magic_dns: false\n\n# Unix socket used for the CLI to connect without authentication\n# Note: for production you will want to set this to something like:\nunix_socket: /var/run/headscale/headscale.sock\nunix_socket_permission: \"0770\"\n#\n# headscale supports experimental OpenID connect support,\n# it is still being tested and might have some bugs, please\n# help us test it.\n# OpenID Connect\n# oidc:\n#   only_start_if_oidc_is_available: true\n#   issuer: \"https://your-oidc.issuer.com/path\"\n#   client_id: \"your-oidc-client-id\"\n#   client_secret: \"your-oidc-client-secret\"\n#   # Alternatively, set `client_secret_path` to read the secret from the file.\n#   # It resolves environment variables, making integration to systemd's\n#   # `LoadCredential` straightforward:\n#   client_secret_path: \"${CREDENTIALS_DIRECTORY}/oidc_client_secret\"\n#   # client_secret and client_secret_path are mutually exclusive.\n#\n#   # The amount of time from a node is authenticated with OpenID until it\n#   # expires and needs to reauthenticate.\n#   # Setting the value to \"0\" will mean no expiry.\n#   expiry: 180d\n#\n#   # Use the expiry from the token received from OpenID when the user logged\n#   # in, this will typically lead to frequent need to reauthenticate and should\n#   # only been enabled if you know what you are doing.\n#   # Note: enabling this will cause `oidc.expiry` to be ignored.\n#   use_expiry_from_token: false\n#\n#   # Customize the scopes used in the OIDC flow, defaults to \"openid\", \"profile\" and \"email\" and add custom query\n#   # parameters to the Authorize Endpoint request. Scopes default to \"openid\", \"profile\" and \"email\".\n#\n#   scope: [\"openid\", \"profile\", \"email\", \"custom\"]\n#   extra_params:\n#     domain_hint: example.com\n#\n#   # List allowed principal domains and/or users. If an authenticated user's domain is not in this list, the\n#   # authentication request will be rejected.\n#\n#   allowed_domains:\n#     - example.com\n#   # Note: Groups from keycloak have a leading '/'\n#   allowed_groups:\n#     - /headscale\n#   allowed_users:\n#     - alice@example.com\n#\n#   # If `strip_email_domain` is set to `true`, the domain part of the username email address will be removed.\n#   # This will transform `first-name.last-name@example.com` to the user `first-name.last-name`\n#   # If `strip_email_domain` is set to `false` the domain part will NOT be removed resulting to the following\n#   user: `first-name.last-name.example.com`\n#\n#   strip_email_domain: true\n\n# Logtail configuration\n# Logtail is Tailscales logging and auditing infrastructure, it allows the control panel\n# to instruct tailscale nodes to log their activity to a remote server.\nlogtail:\n  # Enable logtail for this headscales clients.\n  # As there is currently no support for overriding the log server in headscale, this is\n  # disabled by default. Enabling this will make your clients send logs to Tailscale Inc.\n  enabled: false\n\n# Enabling this option makes devices prefer a random port for WireGuard traffic over the\n# default static port 41641. This option is intended as a workaround for some buggy\n# firewall devices. See https://tailscale.com/kb/1181/firewalls/ for more information.\nrandomize_client_port: false"
		_ = os.WriteFile(confPath, []byte(content), 0644)
	}
	go func() {
		time.Sleep(3 * time.Second)
		if viper.GetBool("enable.headscale") {
			cfg, _ := types.LoadServerConfig()
			app, _ := hscontrol.NewHeadscale(cfg)
			_ = app.Serve()
		}
	}()

}
